#include "GPUKernelManager.h"
#include <iostream>
#include <vector>
#include <cassert>
#include <limits>
#include <chrono>


using namespace std;



/********************* Kernel declarations ************************/
__global__ void pRemKernel(DeviceData *d_devData);
__global__ void PIgXRelThreadPerReadPerProt(DeviceData *d_devData);

//Class functions

GPUKernelManager::GPUKernelManager()
{
}


void GPUKernelManager::init()
{
    cudaSetDevice(GPU_DEVICE); //Sets the device to do the calculations
}



void GPUKernelManager::runBaseKernel(DeviceData *pdevData, DeviceData *d_pdevData) //Assumes P_rem already calculated.
{ 
    unsigned long n_threads = ((unsigned long)pdevData->nReadsProcess * (unsigned long)pdevData->nProt);
    unsigned long n_blocks = (n_threads/NThreadsPerBlock)+1;
    PIgXRelThreadPerReadPerProt<<<n_blocks,NThreadsPerBlock>>>(d_pdevData);
    cudaDeviceSynchronize();
}



void GPUKernelManager::calcPRem(DeviceData *pdevData, DeviceData *d_pdevData)
{
    unsigned long n_threads = ((unsigned long)pdevData->nReadsProcess);
    unsigned long n_blocks = (n_threads/NThreadsPerBlock)+1;
    pRemKernel<<<n_blocks,NThreadsPerBlock>>>(d_pdevData);
    cudaDeviceSynchronize();
}


GPUKernelManager::~GPUKernelManager()
{
}


/********************* Kernel definitions ************************/
__global__ void pRemKernel(DeviceData *d_devData)
{
    const unsigned long threadId = (unsigned long)blockIdx.x*(unsigned long)blockDim.x + (unsigned long)threadIdx.x;
    float * d_TopNFluExpScoresRead;
    float norm_factor=1.0f/((float)d_devData->nFluExp); //To have Prem normalized dividing by number of flu exps.
    if( threadId< (unsigned long)d_devData->nReadsProcess) //One thread per read (threadId=currRead)
    {
        float aux=0;
        d_TopNFluExpScoresRead=&(d_devData->d_TopNFluExpScores[(unsigned long)threadId*(unsigned long)d_devData->nSparsity]); //Pointing towards current read flu scores
        for(unsigned int i=0;i<d_devData->nSparsity;i++)
            aux+=d_TopNFluExpScoresRead[i];
        d_devData->d_pRem[threadId]=norm_factor*(1-aux);
    }
}



__global__ void PIgXRelThreadPerReadPerProt(DeviceData *d_devData)
{
    const unsigned long threadId = (unsigned long)blockIdx.x*(unsigned long)blockDim.x + (unsigned long)threadIdx.x;
    
    float pRemRead,PCurrProtGivenReadRel;
    float * d_TopNFluExpScoresRead, *d_PIgXRelRead;
    unsigned int *d_TopNFluExpIdRead,FluExpIdOffset;
    

    if( threadId< ((unsigned long)d_devData->nReadsProcess*(unsigned long)d_devData->nProt) ) //Only threads within the desired range.
    {
        const unsigned int currRead = threadId/d_devData->nProt; //gets currRead and currProt from thread Id (could still have mix within same block, but it is small)
        const unsigned int currProt = threadId%d_devData->nProt;
        
        pRemRead=d_devData->d_pRem[currRead];
        d_TopNFluExpScoresRead=&(d_devData->d_TopNFluExpScores[(unsigned long)currRead*(unsigned long)d_devData->nSparsity]); //Pointing towards current read flu scores
        d_TopNFluExpIdRead=&(d_devData->d_TopNFluExpId[(unsigned long)currRead*(unsigned long)d_devData->nSparsity]); //Pointing towards current read flu scores ids
        d_PIgXRelRead=&(d_devData->d_MatAux[((unsigned long)currRead*(unsigned long)d_devData->nProt)+(unsigned long)currProt]); //Pointing towards the point in the matrix to be calculated.
        
        //Getting the start of the flu exps prob for the curr protein
        FluExpIdOffset=0; //Starts from the beggining of the fluexp array
        for(unsigned int i=0;i<currProt;i++)
            FluExpIdOffset+=d_devData->d_NFexpForI[i];
       

        PCurrProtGivenReadRel=0;
        for(unsigned int currReadScoreId=0;currReadScoreId<d_devData->nSparsity;currReadScoreId++) //Sparse matrix calculation!
            for(unsigned int currFluExpOfProtId=FluExpIdOffset;currFluExpOfProtId<FluExpIdOffset+(d_devData->d_NFexpForI[currProt]);currFluExpOfProtId++) //For every possible flu exp that the given protein can produce:
                if(d_TopNFluExpIdRead[currReadScoreId]== d_devData->d_FexpIdForI[currFluExpOfProtId]) //If the score Id could also be generated by the current protein
                    PCurrProtGivenReadRel += (d_TopNFluExpScoresRead[currReadScoreId] * d_devData->d_PFexpForI[currFluExpOfProtId]); //Accumulates prob
        PCurrProtGivenReadRel += pRemRead; //Adding normalizing error
        *d_PIgXRelRead=PCurrProtGivenReadRel;
    }
}